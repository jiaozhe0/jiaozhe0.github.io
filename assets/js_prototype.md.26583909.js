import{_ as e,c as t,o as i,d as l}from"./app.4b2b1220.js";const g=JSON.parse('{"title":"构造函数","description":"","frontmatter":{},"headers":[{"level":2,"title":"构造函数","slug":"构造函数-1","link":"#构造函数-1","children":[{"level":3,"title":"new 的执行过程","slug":"new-的执行过程","link":"#new-的执行过程","children":[]}]},{"level":2,"title":"原型对象","slug":"原型对象","link":"#原型对象","children":[{"level":3,"title":"关于原型的方法","slug":"关于原型的方法","link":"#关于原型的方法","children":[]}]},{"level":2,"title":"原型链","slug":"原型链","link":"#原型链","children":[]},{"level":2,"title":"构造函数,原型，实例的关系","slug":"构造函数-原型-实例的关系","link":"#构造函数-原型-实例的关系","children":[]}],"relativePath":"js/prototype.md"}'),r={name:"js/prototype.md"},o=l('<h1 id="构造函数" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数" aria-hidden="true">#</a></h1><p>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便的实现面向对象编程封装，抽象，继承，多态四大特性的编程语言</p><h2 id="构造函数-1" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数-1" aria-hidden="true">#</a></h2><h3 id="new-的执行过程" tabindex="-1">new 的执行过程 <a class="header-anchor" href="#new-的执行过程" aria-hidden="true">#</a></h3><ol><li>创建一个新的对象实例</li><li>将对象实例的[[prototype]]指向构造函数的原型对象</li><li>构造函数内部的 this 指向该新的对象实例</li><li>执行构造函数内部的代码</li><li>如果构造函数返回空对象，则返回该对象，否则返回刚刚创建的新对象</li></ol><h2 id="原型对象" tabindex="-1">原型对象 <a class="header-anchor" href="#原型对象" aria-hidden="true">#</a></h2><ul><li><p>在 JavaScript 中，****proto****属性指向对象的原型对象</p><ul><li>每个对象（包括原型对象）都有****proto****属性来标示自己所继承的原型对象</li><li>所有函数都可以通过<strong>proto</strong>找到 Function 对象</li><li>所有对象都可以通过<strong>proto</strong>找到 Object 对象</li></ul></li><li><p>对于函数来说，每个函数都有一个 <strong>prototype</strong> 属性，该属性为该函数的原型对象</p><ul><li>函数可能是构造函数，所以有原型对象</li><li>原型对象会自动获得一个名为 constructor 的属性，指向构造函数</li><li>任何函数的默认原型对象都是 Object 的实例，这意味着这个实例有一个内部指针指向 Object.prototype</li></ul></li></ul><h3 id="关于原型的方法" tabindex="-1">关于原型的方法 <a class="header-anchor" href="#关于原型的方法" aria-hidden="true">#</a></h3><ul><li>Object.getPrototypeOf(obj):返回指定对象的原型（内部[[Prototype]]属性的值）</li><li>Object.prototype.isPrototypeOf(obj): 用于测试一个对象是否存在于另一个对象的原型链上</li></ul><h2 id="原型链" tabindex="-1">原型链 <a class="header-anchor" href="#原型链" aria-hidden="true">#</a></h2><p>对象之间通过<strong>proto</strong>链接起来，形成原型链，当前对象不存在的属性可以通过原型链一层层往上查找，直到顶层 Object 对象</p><p>一个对象可通过<strong>proto</strong>访问原型对象上的属性和方法，而该原型同样也可通过<strong>proto</strong>访问它的原型对象，这样我们就在实例和原型之间构造了一条原型链。这里我用红色的线将 lily 实例的原型链标了出来</p><h2 id="构造函数-原型-实例的关系" tabindex="-1">构造函数,原型，实例的关系 <a class="header-anchor" href="#构造函数-原型-实例的关系" aria-hidden="true">#</a></h2>',13),a=[o];function n(s,d,h,c,p,u){return i(),t("div",null,a)}const f=e(r,[["render",n]]);export{g as __pageData,f as default};
