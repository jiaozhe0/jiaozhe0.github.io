import{_ as e,c as a,o as i,d as r}from"./app.4b2b1220.js";const m=JSON.parse('{"title":"宏任务与微任务","description":"","frontmatter":{},"headers":[{"level":2,"title":"宏任务(macroTask)","slug":"宏任务-macrotask","link":"#宏任务-macrotask","children":[{"level":3,"title":"消息队列中等待主线程执行的任务。","slug":"消息队列中等待主线程执行的任务。","link":"#消息队列中等待主线程执行的任务。","children":[]},{"level":3,"title":"产生宏任务的","slug":"产生宏任务的","link":"#产生宏任务的","children":[]}]},{"level":2,"title":"微任务(microTask)","slug":"微任务-microtask","link":"#微任务-microtask","children":[{"level":3,"title":"微任务队列","slug":"微任务队列","link":"#微任务队列","children":[]},{"level":3,"title":"产生微任务的方式","slug":"产生微任务的方式","link":"#产生微任务的方式","children":[]}]},{"level":2,"title":"Vue nextTick","slug":"vue-nexttick","link":"#vue-nexttick","children":[]},{"level":2,"title":"参考链接:","slug":"参考链接","link":"#参考链接","children":[]}],"relativePath":"v8/task.md"}'),t={name:"v8/task.md"},l=r('<h1 id="宏任务与微任务" tabindex="-1">宏任务与微任务 <a class="header-anchor" href="#宏任务与微任务" aria-hidden="true">#</a></h1><h2 id="宏任务-macrotask" tabindex="-1">宏任务(macroTask) <a class="header-anchor" href="#宏任务-macrotask" aria-hidden="true">#</a></h2><h3 id="消息队列中等待主线程执行的任务。" tabindex="-1">消息队列中等待主线程执行的任务。 <a class="header-anchor" href="#消息队列中等待主线程执行的任务。" aria-hidden="true">#</a></h3><p>每个宏任务在执行时，V8 都会重新创建栈，随着宏任务中函数调用，栈也回随之变化，但宏任务执行结束时，整个栈被清空，接着主线程继续下一个宏任务</p><h3 id="产生宏任务的" tabindex="-1">产生宏任务的 <a class="header-anchor" href="#产生宏任务的" aria-hidden="true">#</a></h3><ul><li>渲染事件（如解析 DOM，计算布局，绘制）</li><li>用户交互事件（如鼠标点击，滚动页面，放大缩小）</li><li>js 脚本执行事件</li><li>网络请求完成，文件读写完成事件</li><li>定时器：setTimeout,setInterval</li></ul><h2 id="微任务-microtask" tabindex="-1">微任务(microTask) <a class="header-anchor" href="#微任务-microtask" aria-hidden="true">#</a></h2><p>微任务是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前；每个红任务都关联一个微任务队列</p><h3 id="微任务队列" tabindex="-1">微任务队列 <a class="header-anchor" href="#微任务队列" aria-hidden="true">#</a></h3><ul><li>执行 js 代码时，v8 引擎会创建全局执行上下文，同时会创建一个微任务队列</li><li>微任务队列是给 V8 引擎内部使用的，无法通过 js 直接访问</li><li>每个宏任务都关联一个微任务队列</li><li>在执行微任务过程中产生的新的微任务并不会推迟到下一个循环中执行，而时在当前循环中继续执行</li></ul><h3 id="产生微任务的方式" tabindex="-1">产生微任务的方式 <a class="header-anchor" href="#产生微任务的方式" aria-hidden="true">#</a></h3><ul><li>Promise,调用 Promise.resolve()或 Promise.reject()</li><li>使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务</li></ul><blockquote><h3 id="执行顺序微任务-dom-渲染-宏任务" tabindex="-1">执行顺序微任务 &gt; dom 渲染 &gt; 宏任务 <a class="header-anchor" href="#执行顺序微任务-dom-渲染-宏任务" aria-hidden="true">#</a></h3></blockquote><h2 id="vue-nexttick" tabindex="-1">Vue nextTick <a class="header-anchor" href="#vue-nexttick" aria-hidden="true">#</a></h2><h2 id="参考链接" tabindex="-1">参考链接: <a class="header-anchor" href="#参考链接" aria-hidden="true">#</a></h2><p><a href="https://juejin.cn/post/6886602875225833480" target="_blank" rel="noreferrer">掘金</a></p>',16),n=[l];function s(h,d,c,o,u,k){return i(),a("div",null,n)}const v=e(t,[["render",s]]);export{m as __pageData,v as default};
